# Data Representations

---


## 信息存储
- **字节**作为最小的可寻址的内存单位
- **字长**表明指针数据的标称大小
- 多字节对象如何在内存中排列：
	- 大端法和小端法：有效字节在最前面
- `unsigned char*` 看成字节序列
- 位运算和逻辑运算(非零参数都是True)
- *逻辑右移(补0)*和*算术右移(补最高有效位)*
    -  加法和减法的优先级别比位移运算高
    
##整数表示
- C和C++ 都支持signed(默认)和unsigned Java只支持有符号数
    - C `<limits.h>`定义该机器上不同整数数据类型的取值范围
    - C中`TMin = (-TMAX-1)` 
    - Java标准要求采用补码表示且单字节数据类型称为Byte
- signed和unsigned直接转换保证**位模式不变**
- 运算一个有符号一个无符号，`C语言`会强制将有符号数转换为无符号数
- 扩展 `(unsigned) short` 等价于 `(unsigned)(int) short` 即先改变位大小再从signed变为unsigned
	
## 整数运算
- 无符号加法
- 补码加法
- 无符号乘法和补码乘法：乘法运算的**位级表示**都是一样的
- 乘以常数：位移和加减运算
- 除以2的幂
   	- 无符号采用逻辑右移 补码采用算术右移 `x>>k` 
   	- **补码**除以2的幂 
   		- 正数 `x >> k`
   		- 负数需要有偏量 `(x+(1<<k)-1) >> k`
   	
## 浮点数 `(PASS)`
- 二进制小数
- **IEEE**浮点表示
	- 符号s:负数(s=1) 正数(s=0) 0特殊处理
	- 位数M:二进制小数
	- 阶码E:浮点数加权
	- 规格化的值:`exp`位的位模式不全为0也不全为1
	- 非规格化的值:`exp`位全为0 提供0的表示方法
	- 特殊值: `exp`全为1且`frac`全为0可以表示无穷, `exp`全为1而`frac`为非零时表示`NaN`


## 练习题启发
	
- `xor 1`有取反的作用
- `int64_t pll = (int64_t) x*y` **右边的强制类型转**换至关重要，如果去掉则会用32位的值来计算乘法再符号扩展到64位
- `x > 0 || -x >= 0` 当 `x is TMin`时为假


