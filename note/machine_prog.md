# Machine Prog

---

## 前言
- GCC C语言**编译器**以汇编代码的形式产生输出并调用**汇编器**和**连接器**生成可执行的机器代码
- 处理器的机器语言X86-64 IA32是其32位前身

## 程序编码
> linux > gcc -Og -o p p1.c p2.c

## 数据格式
- movb(字节)、movw(字16bit)、movl(双字)、movq（四字)、 movabsq)

## 访问信息
- 操作数指示符
	- 立即数、寄存器和内存引用
	- 寻址模式 P121
- 数据传送指令：数据一个位置复制到另一个位置
	- 传送指令的两个操作数**不能**都指向内存位置 
	- **特例**:任何为寄存器生成32bit值的指令都会把该寄存器的高位部分置成0 `movl`
	- MOVZ零扩展 MOVS符号扩展
	- 理解数据传送如何改变目的寄存器 movb,movw,movl,movq
	- 强制类型转换涉及**大小变化**与**符号变化**时 应先改变**大小**
- 压入和弹出栈数据	
	- 栈向低地址方向增长
	- 压栈是减小栈指针*(%rsp)*的值并将数据保存在内存
	- 出栈从内从读数据再增加栈指针*(%rsp)*的值
	
	
## 算术和逻辑操作
- 加载有效地址
	- `leaq S, D`
	- 可以利用 `leaq`操作实现简单的加减乘除
- 一元和二元操作
	- 一元操作:既是源又是目的 可以是寄存器也可以是一个内存位置
	- 二元操作:第二个操作数既是源又是目的  	
- 位移操作
- 讨论
	- `imulq`和`mulq`乘积存放在寄存器*(%rdx)*高位 *(%rax)*低位
	- `idivq`和`divq`准备被除数*(%rdx %rax)*然后 (rdx保存余数 rax保存商)

## 控制
- 条件码
	- `CMP`和`TEST`**只设置条件码**而不改变任何其他寄存器
	- `CMP`根据两个**操作数之差**来设置条件码 而`TEST`和AND指令行为相同
		- `cmp S1, S2`是基于 **S2-S1** 目的寄存器-源寄存器
		- `test S1, S2`是基于 **S1&S2**
		- `testq %rax, %rax`用来检测*%rax*是负数、正数还是零
- 访问条件码
	- `SET`指令的目的操作数是**低位单字节**寄存器元素之一 为得到一个32bit或64bit的结果 我们必须对高位清零 (movz)
	- `movzbl %al, %exa` Clear rest of *%eax* and rest of *%rax*
- 跳转指令
	- 跳转指令的编码 	
		- 指令编码只需要2个字节
		- 当执行PC相对寻址时 **程序计数器**的值是**跳转指令后面**的那条指令的地址
	- 用条件**控制**来实现条件分支	
	- 用条件**传送**来实现条件分支
		- 计算一个条件的两种操作结果然后再选取其中一个 (受限于一些情况)
		- `comv`指令 
- 循环 do-while/while/for
- switch(开关语句)
	- 通过使用跳转表*jump table*(一个组数)使实现更加高效
	- jmp 指令的操作数前缀有* 表明这是一个间接跳转
	- 默认情况的代表标号是 **.L2**
	
	
## 过程
- 运行时栈
	- C过程调用的一个关键特性在于使用了**栈数据结构**提供的**后进先出**的**内存管理原则** 
	- 当过程P调用过程Q时(call)会将**返回地址**压入P的栈帧(stack frame)中 指明当Q返回时要从P程序的哪个位置继续执行 我们把这个返回地址当做P的栈帧的一部分是因为它存放的是与P有关的状态
- 转移控制
	- 控制从P转到Q只需要将程序计数器 **PC** *(%rip)* 设置为Q的起始位置 
	- `call`指令将P的**返回地址**压入栈 将PC设置为Q起始位置并跳转
	- *(%rsp)* 栈顶指针
- 数据传递
	- x86-64中大部分过程间的数据传送是通过**寄存器**实现的 可以最多传递6个**整型**(例如整数和指针)参数
	- 超过6个的部分通过**栈**来传递且参数7位于**栈顶**
- 栈上的局部存储
	- 过程通过*减小栈指针* `sub`在栈上分配空间 分配结果作为栈帧的一部分
	- 过程运行结束前释放局部储存 `add`
- 寄存器中的局部变量存储空间
	- 被调用者保存寄存器 当P调用过程Q时 Q必须保存这些寄存器的值
	- 调用者保存寄存器 过程Q可以随意修改因此保存好这些数据是P的责任 

## 数组的分配和访问
- 基本原则
- 指针运算
	- `lea` & `mov` 
- 嵌套的数组
	-  `&D[i][j]=start + L(C*i+j)`
- 定长数组
- 变长数组


## 异质的数据结构
- 结构：将多个对象集合到一个单位中
	- C++和Java的*对象*比C语言中的*结构*复杂的多 C语言中**没有**成员对象方法
- 联合：允许用几种不同的类型来引用一个对象(passed)
- 数据对齐
	- 假设一个处理总是从内存中取8个bytes 则地址必须为8的倍数
	- `.align`  2 4 8

	
## 在机器级程序中将控制与数据结合起来
- 理解指针 
- 使用GDB调试器 P194
	- 设置*断点*以查看各个寄存器和内存的位置 `break *location` & `delete`
	- 执行 `stepi`(指令) `nexti`(函数调用)
	- 检查数据 `print` & `x`
- 内存越界引用和缓冲区溢出
	- **缓冲区溢出** **buffer overflow** 通常在栈上分配某个字符数组来保存一个字符串 但字符串的长度超出了为数组分配的空间
- 对抗缓冲区溢出攻击
	- 栈随机化
		- 地址空间布局随机化 -
		- 空操作(passed)
	- 栈破坏检测
		- **破坏**通常发生在超越局部缓冲区的边界时 
		- 在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的*canary*值
	
## 小结
- 了解机器级编程
	- 每条指令都完成一个单独操作
	- C语言缺乏边界安全检查
- Java的目标代码是一种特殊的二进制表示 称为*Java字节代码* 可以看成是虚拟机的机器及程序
	- 相同的代码可以在许多不同机器上执行
	- 而书中涉及的机器级代码只能在x86-64机器上运行